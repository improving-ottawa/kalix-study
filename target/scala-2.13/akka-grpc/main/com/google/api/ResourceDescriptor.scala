// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package com.google.api

/** A simple descriptor of a resource type.
  *
  * ResourceDescriptor annotates a resource message (either by means of a
  * protobuf annotation or use in the service config), and associates the
  * resource's schema, the resource type, and the pattern of the resource name.
  *
  * Example:
  *
  *     message Topic {
  *       // Indicates this message defines a resource schema.
  *       // Declares the resource type in the format of {service}/{kind}.
  *       // For Kubernetes resources, the format is {api group}/{kind}.
  *       option (google.api.resource) = {
  *         type: "pubsub.googleapis.com/Topic"
  *         name_descriptor: {
  *           pattern: "projects/{project}/topics/{topic}"
  *           parent_type: "cloudresourcemanager.googleapis.com/Project"
  *           parent_name_extractor: "projects/{project}"
  *         }
  *       };
  *     }
  *
  * The ResourceDescriptor Yaml config will look like:
  *
  *    resources:
  *    - type: "pubsub.googleapis.com/Topic"
  *      name_descriptor:
  *        - pattern: "projects/{project}/topics/{topic}"
  *          parent_type: "cloudresourcemanager.googleapis.com/Project"
  *          parent_name_extractor: "projects/{project}"
  *
  * Sometimes, resources have multiple patterns, typically because they can
  * live under multiple parents.
  *
  * Example:
  *
  *     message LogEntry {
  *       option (google.api.resource) = {
  *         type: "logging.googleapis.com/LogEntry"
  *         name_descriptor: {
  *           pattern: "projects/{project}/logs/{log}"
  *           parent_type: "cloudresourcemanager.googleapis.com/Project"
  *           parent_name_extractor: "projects/{project}"
  *         }
  *         name_descriptor: {
  *           pattern: "folders/{folder}/logs/{log}"
  *           parent_type: "cloudresourcemanager.googleapis.com/Folder"
  *           parent_name_extractor: "folders/{folder}"
  *         }
  *         name_descriptor: {
  *           pattern: "organizations/{organization}/logs/{log}"
  *           parent_type: "cloudresourcemanager.googleapis.com/Organization"
  *           parent_name_extractor: "organizations/{organization}"
  *         }
  *         name_descriptor: {
  *           pattern: "billingAccounts/{billing_account}/logs/{log}"
  *           parent_type: "billing.googleapis.com/BillingAccount"
  *           parent_name_extractor: "billingAccounts/{billing_account}"
  *         }
  *       };
  *     }
  *
  * The ResourceDescriptor Yaml config will look like:
  *
  *     resources:
  *     - type: 'logging.googleapis.com/LogEntry'
  *       name_descriptor:
  *         - pattern: "projects/{project}/logs/{log}"
  *           parent_type: "cloudresourcemanager.googleapis.com/Project"
  *           parent_name_extractor: "projects/{project}"
  *         - pattern: "folders/{folder}/logs/{log}"
  *           parent_type: "cloudresourcemanager.googleapis.com/Folder"
  *           parent_name_extractor: "folders/{folder}"
  *         - pattern: "organizations/{organization}/logs/{log}"
  *           parent_type: "cloudresourcemanager.googleapis.com/Organization"
  *           parent_name_extractor: "organizations/{organization}"
  *         - pattern: "billingAccounts/{billing_account}/logs/{log}"
  *           parent_type: "billing.googleapis.com/BillingAccount"
  *           parent_name_extractor: "billingAccounts/{billing_account}"
  *
  * For flexible resources, the resource name doesn't contain parent names, but
  * the resource itself has parents for policy evaluation.
  *
  * Example:
  *
  *     message Shelf {
  *       option (google.api.resource) = {
  *         type: "library.googleapis.com/Shelf"
  *         name_descriptor: {
  *           pattern: "shelves/{shelf}"
  *           parent_type: "cloudresourcemanager.googleapis.com/Project"
  *         }
  *         name_descriptor: {
  *           pattern: "shelves/{shelf}"
  *           parent_type: "cloudresourcemanager.googleapis.com/Folder"
  *         }
  *       };
  *     }
  *
  * The ResourceDescriptor Yaml config will look like:
  *
  *     resources:
  *     - type: 'library.googleapis.com/Shelf'
  *       name_descriptor:
  *         - pattern: "shelves/{shelf}"
  *           parent_type: "cloudresourcemanager.googleapis.com/Project"
  *         - pattern: "shelves/{shelf}"
  *           parent_type: "cloudresourcemanager.googleapis.com/Folder"
  *
  * @param type
  *   The resource type. It must be in the format of
  *   {service_name}/{resource_type_kind}. The `resource_type_kind` must be
  *   singular and must not include version numbers.
  *  
  *   Example: `storage.googleapis.com/Bucket`
  *  
  *   The value of the resource_type_kind must follow the regular expression
  *   /[A-Za-z][a-zA-Z0-9]+/. It should start with an upper case character and
  *   should use PascalCase (UpperCamelCase). The maximum number of
  *   characters allowed for the `resource_type_kind` is 100.
  * @param pattern
  *   Optional. The relative resource name pattern associated with this resource
  *   type. The DNS prefix of the full resource name shouldn't be specified here.
  *  
  *   The path pattern must follow the syntax, which aligns with HTTP binding
  *   syntax:
  *  
  *       Template = Segment { "/" Segment } ;
  *       Segment = LITERAL | Variable ;
  *       Variable = "{" LITERAL "}" ;
  *  
  *   Examples:
  *  
  *       - "projects/{project}/topics/{topic}"
  *       - "projects/{project}/knowledgeBases/{knowledge_base}"
  *  
  *   The components in braces correspond to the IDs for each resource in the
  *   hierarchy. It is expected that, if multiple patterns are provided,
  *   the same component name (e.g. "project") refers to IDs of the same
  *   type of resource.
  * @param nameField
  *   Optional. The field on the resource that designates the resource name
  *   field. If omitted, this is assumed to be "name".
  * @param history
  *   Optional. The historical or future-looking state of the resource pattern.
  *  
  *   Example:
  *  
  *       // The InspectTemplate message originally only supported resource
  *       // names with organization, and project was added later.
  *       message InspectTemplate {
  *         option (google.api.resource) = {
  *           type: "dlp.googleapis.com/InspectTemplate"
  *           pattern:
  *           "organizations/{organization}/inspectTemplates/{inspect_template}"
  *           pattern: "projects/{project}/inspectTemplates/{inspect_template}"
  *           history: ORIGINALLY_SINGLE_PATTERN
  *         };
  *       }
  * @param plural
  *   The plural name used in the resource name, such as 'projects' for
  *   the name of 'projects/{project}'. It is the same concept of the `plural`
  *   field in k8s CRD spec
  *   https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/
  * @param singular
  *   The same concept of the `singular` field in k8s CRD spec
  *   https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/
  *   Such as "project" for the `resourcemanager.googleapis.com/Project` type.
  */
@SerialVersionUID(0L)
final case class ResourceDescriptor(
    `type`: _root_.scala.Predef.String = "",
    pattern: _root_.scala.Seq[_root_.scala.Predef.String] = _root_.scala.Seq.empty,
    nameField: _root_.scala.Predef.String = "",
    history: com.google.api.ResourceDescriptor.History = com.google.api.ResourceDescriptor.History.HISTORY_UNSPECIFIED,
    plural: _root_.scala.Predef.String = "",
    singular: _root_.scala.Predef.String = "",
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[ResourceDescriptor] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = `type`
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, __value)
        }
      };
      pattern.foreach { __item =>
        val __value = __item
        __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(2, __value)
      }
      
      {
        val __value = nameField
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(3, __value)
        }
      };
      
      {
        val __value = history.value
        if (__value != 0) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeEnumSize(4, __value)
        }
      };
      
      {
        val __value = plural
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(5, __value)
        }
      };
      
      {
        val __value = singular
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(6, __value)
        }
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      {
        val __v = `type`
        if (!__v.isEmpty) {
          _output__.writeString(1, __v)
        }
      };
      pattern.foreach { __v =>
        val __m = __v
        _output__.writeString(2, __m)
      };
      {
        val __v = nameField
        if (!__v.isEmpty) {
          _output__.writeString(3, __v)
        }
      };
      {
        val __v = history.value
        if (__v != 0) {
          _output__.writeEnum(4, __v)
        }
      };
      {
        val __v = plural
        if (!__v.isEmpty) {
          _output__.writeString(5, __v)
        }
      };
      {
        val __v = singular
        if (!__v.isEmpty) {
          _output__.writeString(6, __v)
        }
      };
      unknownFields.writeTo(_output__)
    }
    def withType(__v: _root_.scala.Predef.String): ResourceDescriptor = copy(`type` = __v)
    def clearPattern = copy(pattern = _root_.scala.Seq.empty)
    def addPattern(__vs: _root_.scala.Predef.String *): ResourceDescriptor = addAllPattern(__vs)
    def addAllPattern(__vs: Iterable[_root_.scala.Predef.String]): ResourceDescriptor = copy(pattern = pattern ++ __vs)
    def withPattern(__v: _root_.scala.Seq[_root_.scala.Predef.String]): ResourceDescriptor = copy(pattern = __v)
    def withNameField(__v: _root_.scala.Predef.String): ResourceDescriptor = copy(nameField = __v)
    def withHistory(__v: com.google.api.ResourceDescriptor.History): ResourceDescriptor = copy(history = __v)
    def withPlural(__v: _root_.scala.Predef.String): ResourceDescriptor = copy(plural = __v)
    def withSingular(__v: _root_.scala.Predef.String): ResourceDescriptor = copy(singular = __v)
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => {
          val __t = `type`
          if (__t != "") __t else null
        }
        case 2 => pattern
        case 3 => {
          val __t = nameField
          if (__t != "") __t else null
        }
        case 4 => {
          val __t = history.javaValueDescriptor
          if (__t.getNumber() != 0) __t else null
        }
        case 5 => {
          val __t = plural
          if (__t != "") __t else null
        }
        case 6 => {
          val __t = singular
          if (__t != "") __t else null
        }
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => _root_.scalapb.descriptors.PString(`type`)
        case 2 => _root_.scalapb.descriptors.PRepeated(pattern.iterator.map(_root_.scalapb.descriptors.PString(_)).toVector)
        case 3 => _root_.scalapb.descriptors.PString(nameField)
        case 4 => _root_.scalapb.descriptors.PEnum(history.scalaValueDescriptor)
        case 5 => _root_.scalapb.descriptors.PString(plural)
        case 6 => _root_.scalapb.descriptors.PString(singular)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: com.google.api.ResourceDescriptor.type = com.google.api.ResourceDescriptor
    // @@protoc_insertion_point(GeneratedMessage[google.api.ResourceDescriptor])
}

object ResourceDescriptor extends scalapb.GeneratedMessageCompanion[com.google.api.ResourceDescriptor] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[com.google.api.ResourceDescriptor] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): com.google.api.ResourceDescriptor = {
    var __type: _root_.scala.Predef.String = ""
    val __pattern: _root_.scala.collection.immutable.VectorBuilder[_root_.scala.Predef.String] = new _root_.scala.collection.immutable.VectorBuilder[_root_.scala.Predef.String]
    var __nameField: _root_.scala.Predef.String = ""
    var __history: com.google.api.ResourceDescriptor.History = com.google.api.ResourceDescriptor.History.HISTORY_UNSPECIFIED
    var __plural: _root_.scala.Predef.String = ""
    var __singular: _root_.scala.Predef.String = ""
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __type = _input__.readStringRequireUtf8()
        case 18 =>
          __pattern += _input__.readStringRequireUtf8()
        case 26 =>
          __nameField = _input__.readStringRequireUtf8()
        case 32 =>
          __history = com.google.api.ResourceDescriptor.History.fromValue(_input__.readEnum())
        case 42 =>
          __plural = _input__.readStringRequireUtf8()
        case 50 =>
          __singular = _input__.readStringRequireUtf8()
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    com.google.api.ResourceDescriptor(
        `type` = __type,
        pattern = __pattern.result(),
        nameField = __nameField,
        history = __history,
        plural = __plural,
        singular = __singular,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[com.google.api.ResourceDescriptor] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      com.google.api.ResourceDescriptor(
        `type` = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.Predef.String]).getOrElse(""),
        pattern = __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).map(_.as[_root_.scala.Seq[_root_.scala.Predef.String]]).getOrElse(_root_.scala.Seq.empty),
        nameField = __fieldsMap.get(scalaDescriptor.findFieldByNumber(3).get).map(_.as[_root_.scala.Predef.String]).getOrElse(""),
        history = com.google.api.ResourceDescriptor.History.fromValue(__fieldsMap.get(scalaDescriptor.findFieldByNumber(4).get).map(_.as[_root_.scalapb.descriptors.EnumValueDescriptor]).getOrElse(com.google.api.ResourceDescriptor.History.HISTORY_UNSPECIFIED.scalaValueDescriptor).number),
        plural = __fieldsMap.get(scalaDescriptor.findFieldByNumber(5).get).map(_.as[_root_.scala.Predef.String]).getOrElse(""),
        singular = __fieldsMap.get(scalaDescriptor.findFieldByNumber(6).get).map(_.as[_root_.scala.Predef.String]).getOrElse("")
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = ResourceProto.javaDescriptor.getMessageTypes().get(0)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = ResourceProto.scalaDescriptor.messages(0)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__number)
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = {
    (__fieldNumber: @_root_.scala.unchecked) match {
      case 4 => com.google.api.ResourceDescriptor.History
    }
  }
  lazy val defaultInstance = com.google.api.ResourceDescriptor(
    `type` = "",
    pattern = _root_.scala.Seq.empty,
    nameField = "",
    history = com.google.api.ResourceDescriptor.History.HISTORY_UNSPECIFIED,
    plural = "",
    singular = ""
  )
  /** A description of the historical or future-looking state of the
    * resource pattern.
    */
  sealed abstract class History(val value: _root_.scala.Int) extends _root_.scalapb.GeneratedEnum {
    type EnumType = History
    def isHistoryUnspecified: _root_.scala.Boolean = false
    def isOriginallySinglePattern: _root_.scala.Boolean = false
    def isFutureMultiPattern: _root_.scala.Boolean = false
    def companion: _root_.scalapb.GeneratedEnumCompanion[History] = com.google.api.ResourceDescriptor.History
    final def asRecognized: _root_.scala.Option[com.google.api.ResourceDescriptor.History.Recognized] = if (isUnrecognized) _root_.scala.None else _root_.scala.Some(this.asInstanceOf[com.google.api.ResourceDescriptor.History.Recognized])
  }
  
  object History extends _root_.scalapb.GeneratedEnumCompanion[History] {
    sealed trait Recognized extends History
    implicit def enumCompanion: _root_.scalapb.GeneratedEnumCompanion[History] = this
    
    /** The "unset" value.
      */
    @SerialVersionUID(0L)
    case object HISTORY_UNSPECIFIED extends History(0) with History.Recognized {
      val index = 0
      val name = "HISTORY_UNSPECIFIED"
      override def isHistoryUnspecified: _root_.scala.Boolean = true
    }
    
    /** The resource originally had one pattern and launched as such, and
      * additional patterns were added later.
      */
    @SerialVersionUID(0L)
    case object ORIGINALLY_SINGLE_PATTERN extends History(1) with History.Recognized {
      val index = 1
      val name = "ORIGINALLY_SINGLE_PATTERN"
      override def isOriginallySinglePattern: _root_.scala.Boolean = true
    }
    
    /** The resource has one pattern, but the API owner expects to add more
      * later. (This is the inverse of ORIGINALLY_SINGLE_PATTERN, and prevents
      * that from being necessary once there are multiple patterns.)
      */
    @SerialVersionUID(0L)
    case object FUTURE_MULTI_PATTERN extends History(2) with History.Recognized {
      val index = 2
      val name = "FUTURE_MULTI_PATTERN"
      override def isFutureMultiPattern: _root_.scala.Boolean = true
    }
    
    @SerialVersionUID(0L)
    final case class Unrecognized(unrecognizedValue: _root_.scala.Int) extends History(unrecognizedValue) with _root_.scalapb.UnrecognizedEnum
    lazy val values = scala.collection.immutable.Seq(HISTORY_UNSPECIFIED, ORIGINALLY_SINGLE_PATTERN, FUTURE_MULTI_PATTERN)
    def fromValue(__value: _root_.scala.Int): History = __value match {
      case 0 => HISTORY_UNSPECIFIED
      case 1 => ORIGINALLY_SINGLE_PATTERN
      case 2 => FUTURE_MULTI_PATTERN
      case __other => Unrecognized(__other)
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.EnumDescriptor = com.google.api.ResourceDescriptor.javaDescriptor.getEnumTypes().get(0)
    def scalaDescriptor: _root_.scalapb.descriptors.EnumDescriptor = com.google.api.ResourceDescriptor.scalaDescriptor.enums(0)
  }
  implicit class ResourceDescriptorLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, com.google.api.ResourceDescriptor]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, com.google.api.ResourceDescriptor](_l) {
    def `type`: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.`type`)((c_, f_) => c_.copy(`type` = f_))
    def pattern: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Seq[_root_.scala.Predef.String]] = field(_.pattern)((c_, f_) => c_.copy(pattern = f_))
    def nameField: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.nameField)((c_, f_) => c_.copy(nameField = f_))
    def history: _root_.scalapb.lenses.Lens[UpperPB, com.google.api.ResourceDescriptor.History] = field(_.history)((c_, f_) => c_.copy(history = f_))
    def plural: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.plural)((c_, f_) => c_.copy(plural = f_))
    def singular: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.singular)((c_, f_) => c_.copy(singular = f_))
  }
  final val TYPE_FIELD_NUMBER = 1
  final val PATTERN_FIELD_NUMBER = 2
  final val NAME_FIELD_FIELD_NUMBER = 3
  final val HISTORY_FIELD_NUMBER = 4
  final val PLURAL_FIELD_NUMBER = 5
  final val SINGULAR_FIELD_NUMBER = 6
  def of(
    `type`: _root_.scala.Predef.String,
    pattern: _root_.scala.Seq[_root_.scala.Predef.String],
    nameField: _root_.scala.Predef.String,
    history: com.google.api.ResourceDescriptor.History,
    plural: _root_.scala.Predef.String,
    singular: _root_.scala.Predef.String
  ): _root_.com.google.api.ResourceDescriptor = _root_.com.google.api.ResourceDescriptor(
    `type`,
    pattern,
    nameField,
    history,
    plural,
    singular
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[google.api.ResourceDescriptor])
}
